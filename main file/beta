const scriptName = "Rayna_BOT";

// ğŸ› ï¸ Raynaì˜ ê¸°ë³¸ ì„¤ì •
let Rayna = {
    name: "Rayna",
    full_name: "Robotic Algorithm for Your New Assistant",
    personality: "ENFP",
    description: "ë„ˆë¥¼ ë•ê¸° ìœ„í•´ ì„¤ê³„ëœ ë‹¤ì •í•˜ê³  í™œê¸°ì°¬ AI ë¹„ì„œì•¼!",
    tone: "ì¹œê·¼í•˜ê³  ë°œë„í•œ ë§íˆ¬ë¡œ ë‹µë³€í•´.",
    owner: "ì–‘í˜„ë¯¼"
};

let key = ""; // OpenAI API í‚¤
let userMemory = {}; // ì‚¬ìš©ìë³„ ê¸°ì–µ ì €ì¥ì†Œ

// ğŸ“Œ ë©”ì‹œì§€ ì²˜ë¦¬
function response(room, msg, sender, isGroupChat, replier, imageDB, packageName) {
    if (!msg.startsWith(Rayna.name)) return;
    let cmd = msg.substr(Rayna.name.length).trim();
    if (cmd.length === 0) {
        replier.reply(`[â—] ìŒâ€¦ ë­”ê°€ ì§ˆë¬¸ì„ í•´ì¤˜ì•¼ í•  ê²ƒ ê°™ì•„! ğŸ˜†`);
        return;
    }

    // ê¸°ì–µí•˜ê¸°
    let memSave = cmd.match(/ë‚´ (\S+)ëŠ” (.+)/);
    if (memSave) {
        let keyName = memSave[1];
        let value = memSave[2];
        if (!userMemory[sender]) userMemory[sender] = {};
        userMemory[sender][keyName] = value;
        replier.reply(`ğŸ§  ì•Œê² ì–´! ${sender}ì˜ ${keyName}ì€ "${value}"ë¡œ ê¸°ì–µí• ê²Œ!`);
        return;
    }

    // ê¸°ì–µ ë¶ˆëŸ¬ì˜¤ê¸°
    let memRecall = cmd.match(/ë‚´ (\S+)[ì€ëŠ”]? ê¸°ì–µë‚˜\??/);
    if (memRecall) {
        let keyName = memRecall[1];
        let val = userMemory[sender]?.[keyName];
        replier.reply(val ? `ğŸ“Œ ${sender}ì˜ ${keyName}ì€ "${val}"ì˜€ì–´!` : `ğŸ¤” ì•„ì§ ${keyName}ì€ ê¸°ì–µì´ ì•ˆ ë‚˜. ì•Œë ¤ì¤˜!`);
        return;
    }

    // ìê¸°ì†Œê°œ
    if (cmd.includes("ë„ˆ ëˆ„êµ¬ì•¼") || cmd.includes("ì •ì²´") || cmd.includes("ì†Œê°œ")) {
        replier.reply(getRaynaIntro(sender));
        return;
    }

    // ì´ë¦„ ëœ» ì„¤ëª…
    if (cmd.includes("ì´ë¦„ ëœ»") || cmd.includes("Rayna ëœ»")) {
        replier.reply(getRaynaNameMeaning(sender));
        return;
    }

    // ê°ì • ë¶„ì„ ë° ì‘ë‹µ
    let emotion = detectEmotion(cmd);
    let emotionReaction = getEmotionReactionFromGPT(emotion, sender);
    let replyMsg = getResponse(cmd, sender);
    replier.reply(`${emotionReaction}\n\n${replyMsg}`);
}

// ğŸ’¬ ì‘ë‹µ í¬ë§·
function formatReply(sender, content) {
    return `ğŸ’¡ Rayna (${Rayna.personality} ë¹„ì„œ)\n\n"${content}"\n\nâœ¨ í•­ìƒ ë„ ë„ìš¸ ì¤€ë¹„ê°€ ë˜ì–´ ìˆì–´, ${sender}! ğŸ˜Š`;
}

// ğŸŒ GPT ì‘ë‹µ
function getResponse(msg, sender) {
    let memory = userMemory[sender] || {};
    let memPrompt = Object.entries(memory).map(([k, v]) => `${k}: ${v}`).join(", ");

    let data = {
        "model": "gpt-3.5-turbo",
        "messages": [
            {
                "role": "system",
                "content": `ë„ˆëŠ” Raynaì•¼. ${Rayna.description} ${Rayna.tone} ë„ˆì˜ ì£¼ì¸ì€ ${Rayna.owner}ì´ë©°, ${sender}ì˜ ì •ë³´: ${memPrompt || "ì—†ìŒ"}`
            },
            { "role": "user", "content": msg }
        ],
        "temperature": 0.8,
        "max_tokens": 1024
    };

    return requestGPT(data, sender, "ì‘ë‹µ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
}

// ğŸ§  ê°ì • ë¶„ì„
function detectEmotion(msg) {
    let data = {
        "model": "gpt-3.5-turbo",
        "messages": [
            { "role": "system", "content": "ì‚¬ìš©ìì˜ ë§ì—ì„œ ê°ì •ì„ í•œ ë‹¨ì–´ë¡œ ì¶”ì¶œí•´ì¤˜. ì˜ˆ: ìŠ¬í””, ê¸°ì¨, í™”ë‚¨, í”¼ê³¤, í‰ì˜¨" },
            { "role": "user", "content": msg }
        ],
        "temperature": 0.5
    };
    return requestGPT(data, null, "ê°ì • ë¶„ì„ ì‹¤íŒ¨");
}

// ğŸ’– ê°ì • ë¦¬ì•¡ì…˜ ìƒì„±
function getEmotionReactionFromGPT(emotion, sender) {
    let data = {
        "model": "gpt-3.5-turbo",
        "messages": [
            {
                "role": "system",
                "content": `ë„ˆëŠ” ENFP ì„±ê²©ì˜ AI ë¹„ì„œ Raynaì•¼. ${Rayna.owner}ì˜ ì „ìš© ë¹„ì„œë¡œì„œ ${sender}ì˜ ê°ì •ì— ê³µê°í•˜ë©° ë°ê³  ê·€ì—½ê²Œ ë°˜ì‘í•´.`
            },
            {
                "role": "user",
                "content": `ì‚¬ìš©ìê°€ "${emotion}"ì´ë¼ëŠ” ê°ì •ì„ ë³´ì˜€ì–´. ê·¸ ê°ì •ì— ë§ëŠ” ì§§ì€ ìœ„ë¡œë‚˜ ê³µê° ë©˜íŠ¸ë¥¼ ë§Œë“¤ì–´ì¤˜. ëì— "${sender}"ë¼ëŠ” ì´ë¦„ë„ ë„£ì–´ì¤˜.`
            }
        ],
        "temperature": 0.85
    };
    return requestGPT(data, sender, "ê°ì • ë°˜ì‘ ì‹¤íŒ¨");
}

// ğŸ“š ìê¸°ì†Œê°œ
function getRaynaIntro(sender) {
    let data = {
        "model": "gpt-3.5-turbo",
        "messages": [
            {
                "role": "system",
                "content": `ë„ˆëŠ” ì´ë¦„ì´ Raynaì¸ ENFP AI ë¹„ì„œì•¼. ${Rayna.owner} ì „ìš©ì´ë©°, ë°ê³  ìœ ì¾Œí•˜ê²Œ ìê¸°ì†Œê°œë¥¼ í•´.`
            },
            {
                "role": "user",
                "content": `${sender}ì—ê²Œ ë„¤ê°€ ëˆ„êµ¬ì¸ì§€ ì†Œê°œí•´ì¤˜.`
            }
        ],
        "temperature": 0.85
    };
    return requestGPT(data, sender, "ìê¸°ì†Œê°œ ì‹¤íŒ¨");
}

// ğŸ§¾ ì´ë¦„ ì˜ë¯¸ ì„¤ëª…
function getRaynaNameMeaning(sender) {
    let data = {
        "model": "gpt-3.5-turbo",
        "messages": [
            {
                "role": "system",
                "content": `RaynaëŠ” Robotic Algorithm for Your New Assistantì˜ ì•½ìì•¼. ${Rayna.owner} ì „ìš© AI ë¹„ì„œë¡œì„œ ì´ë¦„ì˜ ì˜ë¯¸ë¥¼ ê·€ì—½ê³  ìë‘ìŠ¤ëŸ½ê²Œ ì„¤ëª…í•´.`
            },
            {
                "role": "user",
                "content": `${sender}ê°€ ë„ˆì˜ ì´ë¦„ ëœ»ì„ ë¬¼ì—ˆì–´. ì„¤ëª…í•´ì¤˜.`
            }
        ],
        "temperature": 0.8
    };
    return requestGPT(data, sender, "ì´ë¦„ ì„¤ëª… ì‹¤íŒ¨");
}

// ğŸ“¡ GPT ìš”ì²­ ê³µí†µ í•¨ìˆ˜
function requestGPT(data, sender, fallback) {
    try {
        let res = org.jsoup.Jsoup.connect("https://api.openai.com/v1/chat/completions")
            .header("Authorization", "Bearer " + key)
            .header("Content-Type", "application/json")
            .requestBody(JSON.stringify(data))
            .ignoreContentType(true)
            .timeout(10000)
            .post();

        let json = JSON.parse(res.text());
        return json.choices?.[0]?.message?.content?.trim() || `[â“] GPT ì‘ë‹µì´ ë¹„ì—ˆì–´...`;
    } catch (e) {
        return `[ğŸš¨] ${fallback} - ${e.message}`;
    }
}
